!
! MODULE with definition and operations of Fourier series
!
! Copyright (C) 2003  Alberto Ramos <alberto@martin.ft.uam.es>
!
! This program is free software; you can redistribute it and/or modify
! it under the terms of the GNU General Public License as published by
! the Free Software Foundation; either version 2 of the License, or
! (at your option) any later version.
!
! This program is distributed in the hope that it will be useful,
! but WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program; if not, write to the Free Software
! Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307
! USA
! 

! **************************************************
! *
MODULE FourierF
! *
! ***************************************************

  USE Constants, ONLY: PI => PI_DP, DPI => TWOPI_DP, UnitImag_DPC
  USE NumTypes

  
  Integer, Parameter :: MaxTerm = 40


  Type Fourier_Serie
     Complex (kind=DPC) :: Coef(-MaxTerm:MaxTerm)
     Integer :: Nterm = MaxTerm
  End Type Fourier_Serie
  
  Type Fourier_Serie_2D
     Complex (kind=DPC) :: Coef(-MaxTerm:MaxTerm,-MaxTerm:MaxTerm)
     Integer :: Nterm = MaxTerm
  End Type Fourier_Serie_2D
  

  Interface Operator (+)
     Module Procedure Add, Add_2D, Pos, Pos_2D
  End Interface
  
  Interface Operator (-)
     Module Procedure Sub, Sub_2D, Neg, Neg_2D
  End Interface
  
  Interface Operator (*)
     Module Procedure Prod, Prod_2D, Prodcte, Prodcte_2D, Prodcte2,&
          & Prodcte2_2D, &
          & ProdCcte, ProdCcte_2D, ProdCcte2, ProdCcte2_2D
  End Interface

!  Interface Operator (/)
!     Module Procedure Div_1D, Div_2D
!  End Interface
  
  Interface Operator (**)
     Module Procedure NewExp_1D, NewExp_2D
  End Interface
  
  Interface Assignment (=)
     Module Procedure Equal, Equal_2D
  End Interface
  

  Interface Init_Serie
     Module Procedure Init_Serie_1D, Init_Serie_2D
  End Interface

  Interface Equal_Func
     Module Procedure Equal_Func_1D, Equal_Func_2D
  End Interface

  Interface Eval_Serie
     Module Procedure Eval_Serie_1D, Eval_Serie_2D
  End Interface

  Interface Unit
     Module Procedure Unit_1D, Unit_2D
  End Interface

  Interface ExpS
     Module Procedure ExpS, ExpS_2D
  End Interface

  Interface NewExp
     Module Procedure NewExp_1D, NewExp_2D
  End Interface

  Interface Save_Serie
     Module Procedure Save_1D, Save_2D
  End Interface

  Interface Read_Serie
     Module Procedure Read_1D, Read_2D
  End Interface

  Interface Conjg
     Module Procedure ConjgFS_1D, ConjgFS_2D
  End Interface

  Private PI, DPI, Add, Add_2D, Prod, Prod_2D, Equal, Equal_2D,&
       & Eval_Serie_1D, Eval_Serie_2D, Sub, Sub_2D, Prodcte, &
       & Procte_2D, ExpS, ExpS_2D, Neg, Neg_2D, Pos, Pos_2D, &
       & DFT_1D, DFT_2D, FFT_1D, NewExp_1D, NewExp_2D, ConjgFS_1D, &
       & ConjgFS_2D

CONTAINS

! ********************************
! *
  Subroutine Init_Serie_1D(Serie, Nespacio)
! *
! ********************************
! * Allocate memory space for  
! * the coefficients.
! ********************************
    
    Integer, Intent (in) :: Nespacio
    Type (Fourier_Serie), Intent (out) :: Serie
  

    Serie%Nterm = Nespacio
    Serie%Coef = (0.0_DP, 0.0_DP)

    Return
  End Subroutine Init_Serie_1D

! ********************************
! *
  Subroutine Init_Serie_2D(Serie, Nespacio)
! *
! ********************************
! * Allocate memory space for  
! * the coefficients.
! ********************************
    
    Integer, Intent (in) :: Nespacio
    Type (Fourier_Serie_2D), Intent (out) :: Serie
  

    Serie%Nterm = Nespacio
    Serie%Coef = (0.0_DP, 0.0_DP)

    Return
  End Subroutine Init_Serie_2D
  


! ********************************
! *
  Subroutine Unit_1D(Serie, Nterm)
! *
! ********************************
! * Allocate space for the serie
! * Serie, and returns it with
! * the unit serie (0 fourier 
! * coefficient = 1).
! ********************************

    Type (Fourier_Serie), Intent (out) :: Serie
    Integer, Intent (in) :: Nterm


    Serie%Coef = (0.0_DP, 0.0_DP)
    Serie%Coef(0) = (1.0_DP, 0.0_DP)

    Return
  End Subroutine Unit_1D

! ********************************
! *
  Subroutine Unit_2D(Serie, Nterm)
! *
! ********************************
! * Allocate space for the serie
! * Serie, and returns it with
! * the unit serie (00 fourier 
! * coefficient = 1).
! ********************************

    Type (Fourier_Serie_2D), Intent (out) :: Serie


    Serie%Coef = (0.0_DP, 0.0_DP)
    Serie%Coef(0,0) = (1.0_DP, 0.0_DP)

    Return
  End Subroutine Unit_2D

! ********************************
! *
  Type (Fourier_Serie_2D) Function Prodcte_2D(D, Serie2) Result (Prod)
! *
! ********************************
! * Calculates the product of a 
! * Fourier series and a number.
! ********************************

    Type (Fourier_Serie_2D), Intent (in) :: Serie2
    Real (kind=DP), Intent (in) :: D


    Prod%Coef = D * Serie2%Coef

    Return
  End Function Prodcte_2D

! ********************************
! *
  Type (Fourier_Serie_2D) Function Prodcte2_2D(Serie2, D) Result (Prod)
! *
! ********************************
! * Calculates the product of a 
! * Fourier series and a number.
! ********************************

    Type (Fourier_Serie_2D), Intent (in) :: Serie2
    Real (kind=DP), Intent (in) :: D


    Prod%Coef = D * Serie2%Coef

    Return
  End Function Prodcte2_2D

! ********************************
! *
  Type (Fourier_Serie_2D) Function Prod_2D(Serie1, Serie2) Result (Prod)
! *
! ********************************
! * Calculates the product of two
! * Fourier series.
! ********************************

    Type (Fourier_Serie_2D), Intent (in) :: Serie1, Serie2

    If (Serie1%Nterm > Serie2%Nterm) Then
       Ntot = Serie2%Nterm
    Else
       Ntot = Serie1%Nterm
    End If
    

    Do N2 = -Ntot, Ntot
       Do N1 = -Ntot, Ntot
          Prod%Coef(N1,N2) = (0.0_DP, 0.0_DP)
          Do I1 = Max(N1 - Ntot, -Ntot), Min(N1 + Ntot, Ntot)
             Do I2 = Max(N2 - Ntot, -Ntot), Min(N2 + Ntot, Ntot)
                Prod%Coef(N1, N2) = Prod%Coef(N1,N2) + &
                     & Serie1%Coef(I1,I2) * Serie2%Coef(N1-I1, N2-I2)
             End Do
          End Do
       End Do
    End Do
    Prod%Nterm = Ntot
    

    Return
  End Function Prod_2D

! ********************************
! *
  Type (Fourier_Serie) Function Prodcte(D, Serie2)
! *
! ********************************
! * Calculates the product of a
! * Fourier series and a number.
! ********************************

    Type (Fourier_Serie), Intent (in) :: Serie2
    Real (kind=DP), Intent (in) :: D
    

    Prodcte%Coef = D * Serie2%Coef

    Return
  End Function Prodcte

! ********************************
! *
  Type (Fourier_Serie) Function Prodcte2(Serie2, D)
! *
! ********************************
! * Calculates the product of a
! * Fourier series and a number.
! ********************************

    Type (Fourier_Serie), Intent (in) :: Serie2
    Real (kind=DP), Intent (in) :: D
    

    Prodcte2%Coef = D * Serie2%Coef

    Return
  End Function Prodcte2

! ********************************
! *
  Type (Fourier_Serie) Function Prod(Serie1, Serie2)
! *
! ********************************
! * Calculates the product of two
! * Fourier series.
! ********************************

    Type (Fourier_Serie), Intent (in) :: Serie1, Serie2


    If (Serie1%Nterm > Serie2%Nterm) Then
       Ntot = Serie2%Nterm
    Else
       Ntot = Serie1%Nterm
    End If
    

    Do J = -Ntot, Ntot
       Prod%Coef(J) = (0.0_DP, 0.0_DP)
       Do I = Max(J - Ntot, -Ntot), Min(J + Ntot, Ntot)
          Prod%Coef(J) = Prod%Coef(J) + &
               & Serie1%Coef(I) * Serie2%Coef(J-I)
       End Do
    End Do
    Prod%Nterm = Ntot

    Return
  End Function Prod
  
! ********************************
! *
  Type (Fourier_Serie) Function ExpS(Serie, Nex)
! *
! ********************************
! * "Exponentiates" a fourier series
! * in a fast way.
! ********************************
    

    Type (Fourier_Serie), Intent (in) :: Serie
    Integer, Intent (in) :: Nex

    Integer, Parameter :: Maxcfr = 32
    Integer :: Bin(Maxcfr), Nmax
    Type (Fourier_Serie), Allocatable :: Acum(:)

    If (Nex == 0) Then
       CALL Unit(ExpS, Serie%Nterm)
       Return
    End If
    
    ! Firs we need the binary decomposition of 
    ! Nex
    Do I = 1, Maxcfr
       Bin(I) = Int(Mod(Nex, 2**I)/(2**(I-1)))
       If (Bin(I) == 1) Nmax = I
!       Write(*,*)Bin(I)
    End Do

    Allocate(Acum(Nmax), STAT = Ierr)
    If (Ierr > 0) Then
       Write(0,*)'ExpS: Out of memory.'
       Stop
    End If
    
    Acum(1) = Serie
    Do I = 2, Nmax
       Acum(I) = Acum(I-1) * Acum(I-1)
    End Do
    
    ExpS = Acum(Nmax)
    Do I = Nmax - 1, 1, -1
       If (Bin(I) == 1) Then
          ExpS = ExpS * Acum(I)
       End If
    End Do
    
    Deallocate(Acum)
   
    Return
  End Function ExpS

! ********************************
! *
  Type (Fourier_Serie) Function NewExp_1D(Serie, Nex) Result (NewExp)
! *
! ********************************
! * "Exponentiates" a fourier series
! * in a fast way.
! ********************************
    

    Type (Fourier_Serie), Intent (in) :: Serie
    Integer, Intent (in) :: Nex

    Integer, Parameter :: Maxcfr = 32
    Integer :: Bin(Maxcfr), Nmax
    Type (Fourier_Serie) :: Acum

    If (Nex == 0) Then
       CALL Unit(NewExp, Serie%Nterm)
       Return
    End If
    
    ! Firs we need the binary decomposition of 
    ! Nex
    Do I = 1, Maxcfr
       Bin(I) = Int(Mod(Nex, 2**I)/(2**(I-1)))
       If (Bin(I) == 1) Nmax = I
    End Do

    CALL Unit(Acum, Serie%Nterm)
    Acum = Serie
    CALL Unit(NewExp, Serie%Nterm)
    Do I = 1, Nmax - 1
       If (Bin(I) == 1) Then
          NewExp = NewExp * Acum
       End If
       Acum = Acum * Acum
    End Do

    NewExp = NewExp * Acum

    Return
  End Function NewExp_1D

! ********************************
! *
  Type (Fourier_Serie_2D) Function NewExp_2D(Serie, Nex) Result (NewExp)
! *
! ********************************
! * "Exponentiates" a fourier series
! * in a fast way.
! ********************************
    

    Type (Fourier_Serie_2D), Intent (in) :: Serie
    Integer, Intent (in) :: Nex

    Integer, Parameter :: Maxcfr = 32
    Integer :: Bin(Maxcfr), Nmax
    Type (Fourier_Serie_2D) :: Acum

    If (Nex == 0) Then
       CALL Unit(NewExp, Serie%Nterm)
       Return
    End If
    
    ! Firs we need the binary decomposition of 
    ! Nex
    Do I = 1, Maxcfr
       Bin(I) = Int(Mod(Nex, 2**I)/(2**(I-1)))
       If (Bin(I) == 1) Nmax = I
    End Do

    CALL Unit(Acum, Serie%Nterm)
    Acum = Serie
    CALL Unit(NewExp, Serie%Nterm)
    Do I = 1, Nmax - 1
       If (Bin(I) == 1) Then
          NewExp = NewExp * Acum
       End If
       Acum = Acum * Acum
    End Do

    NewExp = NewExp * Acum

    Return
  End Function NewExp_2D
  
! ********************************
! *
  Type (Fourier_Serie_2D) Function ExpS_2D(Serie, Nex)
! *
! ********************************
! * "Exponentiates" a fourier series
! * in a fast way
! ********************************

    Type (Fourier_Serie_2D), Intent (in) :: Serie
    Integer, Intent (in) :: Nex

    Integer, Parameter :: Maxcfr = 32
    Integer :: Bin(Maxcfr), Nmax
    Type (Fourier_Serie_2D), Allocatable :: Acum(:)

!    CALL Init_Serie(ExpS, Serie%Nterm)

    If (Nex == 0) Then
       CALL Unit(ExpS_2D, Serie%Nterm)
       Return
    End If

    ! Firs we need the binary decomposition of 
    ! Nex
    Do I = 1, Maxcfr
       Bin(I) = Int(Mod(Nex, 2**I)/(2**(I-1)))
       If (Bin(I) == 1) Nmax = I
!       Write(*,*)Bin(I)
    End Do

    Allocate(Acum(Nmax), STAT = Ierr)
    If (Ierr > 0) Then
       Write(0,*)'ExpS_2D: Out of memory.'
       Stop
    End If
    
    Acum(1) = Serie
    Do I = 2, Nmax
       Acum(I) = Acum(I-1) * Acum(I-1)
    End Do
    
    ExpS_2D = Acum(Nmax)
    Do I = Nmax - 1, 1, -1
       If (Bin(I) == 1) Then
          ExpS_2D = ExpS_2D * Acum(I)
       End If
    End Do
    
    Deallocate(Acum)
   
    Return
  End Function ExpS_2D
  
! ********************************
! *
  Type (Fourier_Serie) Function Add(Serie1, Serie2)
! *
! ********************************
! * Add two fourier series.
! ********************************

    Type (Fourier_Serie), Intent (in) :: Serie1, Serie2


    If (Serie1%Nterm > Serie2%Nterm) Then
       Add = Serie1
       Add%Coef(-Serie2%Nterm:Serie2%Nterm) = &
            & Add%Coef(-Serie2%Nterm:Serie2%Nterm) + &
            & Serie2%Coef(:) 
    Else
       Add = Serie2
       Add%Coef(-Serie1%Nterm:Serie1%Nterm) = &
            & Add%Coef(-Serie1%Nterm:Serie1%Nterm) + &
            & Serie1%Coef(:) 
       
    End If
    
    
    Return
  End Function Add      

! ********************************
! *
  Type (Fourier_Serie) Function Neg(Serie)
! *
! ********************************
! * Add two fourier series.
! ********************************

    Type (Fourier_Serie), Intent (in) :: Serie


    Neg%Coef = - Serie%Coef
    Neg%Nterm = Serie%Nterm
    
    Return
  End Function Neg

! ********************************
! *
  Type (Fourier_Serie) Function Pos(Serie)
! *
! ********************************
! * Add two fourier series.
! ********************************

    Type (Fourier_Serie), Intent (in) :: Serie


    Pos%Coef = Serie%Coef
    Pos%Nterm = Serie%Nterm
    
    Return
  End Function Pos

! ********************************
! *
  Type (Fourier_Serie_2D) Function Neg_2D(Serie) Result (Neg)
! *
! ********************************
! * Calclates the opposite of a fourier
! * serie.
! ********************************

    Type (Fourier_Serie_2D), Intent (in) :: Serie


    Neg%Coef = - Serie%Coef
    Neg%Nterm = Serie%Nterm
    
    Return
  End Function Neg_2D

! ********************************
! *
  Type (Fourier_Serie_2D) Function Pos_2D(Serie) Result (Pos)
! *
! ********************************
! * Calclates the opposite of a fourier
! * serie.
! ********************************

    Type (Fourier_Serie_2D), Intent (in) :: Serie

    
    Pos%Coef = Serie%Coef
    Pos%Nterm = Serie%Nterm
    
    Return
  End Function Pos_2D

! ********************************
! *
  Type (Fourier_Serie_2D) Function Add_2D(Serie1, Serie2)
! *
! ********************************
! * Add two fourier series.
! ********************************

    Type (Fourier_Serie_2D), Intent (in) :: Serie1, Serie2

    
    If (Serie1%Nterm > Serie2%Nterm) Then
       Add_2D = Serie1
       Add_2D%Coef(-Serie2%Nterm:Serie2%Nterm,-Serie2%Nterm:Serie2%Nterm) = &
            & Add_2D%Coef(-Serie2%Nterm:Serie2%Nterm,-Serie2%Nterm:Serie2%Nterm)&
            & + Serie2%Coef(:,:) 
    Else
       Add_2D = Serie2
       Add_2D%Coef(-Serie1%Nterm:Serie1%Nterm,-Serie1%Nterm:Serie1%Nterm) = &
            & Add_2D%Coef(-Serie1%Nterm:Serie1%Nterm,-Serie1%Nterm:Serie1%Nterm) + &
            & Serie1%Coef(:,:) 
    End If

    
    Return
  End Function Add_2D

! ********************************
! *
  Type (Fourier_Serie) Function Sub(Serie1, Serie2)
! *
! ********************************
! * Substract two fourier series.
! ********************************

    Type (Fourier_Serie), Intent (in) :: Serie1, Serie2
    
    If (Serie1%Nterm > Serie2%Nterm) Then
       Sub = Serie1
       Sub%Coef(-Serie2%Nterm:Serie2%Nterm) = &
            & Sub%Coef(-Serie2%Nterm:Serie2%Nterm) - &
            & Serie2%Coef(:) 
    Else
       Sub = Serie2
       Sub%Coef(-Serie1%Nterm:Serie1%Nterm) = &
            & Sub%Coef(-Serie1%Nterm:Serie1%Nterm) - &
            & Serie1%Coef(:)
       
       Sub%Coef(:) = -Sub%Coef(:)
    End If
    
    
    Return
  End Function Sub

! ********************************
! *
  Type (Fourier_Serie_2D) Function Sub_2D(Serie1, Serie2)
! *
! ********************************
! * Substract two fourier series.
! ********************************

    Type (Fourier_Serie_2D), Intent (in) :: Serie1, Serie2
    
    If (Serie1%Nterm > Serie2%Nterm) Then
       Sub_2D = Serie1
       Sub_2D%Coef(-Serie2%Nterm:Serie2%Nterm,-Serie2%Nterm:Serie2%Nterm) = &
            & Sub_2D%Coef(-Serie2%Nterm:Serie2%Nterm,-Serie2&
            & %Nterm:Serie2%Nterm) - Serie2%Coef(:,:) 

       Sub_2D%Nterm = Serie1%Nterm
    Else
       Sub_2D = Serie2
       Sub_2D%Coef(-Serie1%Nterm:Serie1%Nterm,-Serie2%Nterm:Serie2%Nterm) = &
            & Sub_2D%Coef(-Serie1%Nterm:Serie1%Nterm,-Serie2&
            & %Nterm:Serie2%Nterm) - Serie1%Coef(:,:) 
       
       Sub_2D%Coef(:,:) = -Sub_2D%Coef(:,:)
       Sub_2D%Nterm = Serie2%Nterm
    End If

    
    Return
  End Function Sub_2D

! ********************************
! *
  Subroutine Equal_Func_1D(Serie, Func, Nterm)
! *
! ********************************
! * Assign Serie2 to Serie1
! ********************************

    Integer, Intent (in) :: Nterm
    Type (Fourier_Serie), Intent (out) :: Serie

    Interface
       Function Func(N1)
         USE NumTypes

         Integer, Intent (in)  :: N1
         Complex (kind=DPC) :: Func
       End Function Func
    End Interface

    
    Do I = -Nterm, Nterm
       Serie%Coef(I) = Func(I)
    End Do
    

    Return
  End Subroutine Equal_Func_1D


! ********************************
! *
  Subroutine Equal_Func_2D(Serie, Func, Nterm)
! *
! ********************************
! * Assign Serie2 to Serie1
! ********************************

    Integer, Intent (in) :: Nterm
    Type (Fourier_Serie_2D), Intent (out) :: Serie

    Interface
       Function Func(N1, N2)
         USE NumTypes

         Integer, Intent (in)  :: N1, N2
         Complex (kind=DPC) :: Func
       End Function Func
    End Interface

    
    Do J = -Nterm, Nterm
       Do I = -Nterm, Nterm
          Serie%Coef(J, I) = Func(J, I)
       End Do
    End Do

    Return
  End Subroutine Equal_Func_2D


! ********************************
! *
  Subroutine Equal(Serie1, Serie2)
! *
! ********************************
! * Assign Serie2 to Serie1
! ********************************

    Type (Fourier_Serie), Intent (in) :: Serie2
    Type (Fourier_Serie), Intent (out) :: Serie1

    
    Serie1%Coef = Serie2%Coef
    Serie1%Nterm = Serie2%Nterm
    
    Return
  End Subroutine Equal

! ********************************
! *
  Subroutine Equal_2D(Serie1, Serie2)
! *
! ********************************
! * Assign Serie2 to Serie1
! ********************************

    Type (Fourier_Serie_2D), Intent (in) :: Serie2
    Type (Fourier_Serie_2D), Intent (out) :: Serie1

    
    Serie1%Coef = Serie2%Coef
    Serie1%Nterm = Serie2%Nterm
    
    Return
  End Subroutine Equal_2D


! ********************************
! *
  Complex (kind=DPC) Function Eval_Serie_1D(Serie, X, Tx) Result (Val)
! *
! ********************************
! * Evaluates the fourier Serie in
! * the point X with period
! * Tx.
! ********************************
    
    Type (Fourier_Serie), Intent (in) :: Serie
    Real (kind=DP), Intent (in) :: X, Tx


    Val = (0.0_DP, 0.0_DP)
    Do I = -Serie%Nterm, Serie%Nterm
       Val = Val + Serie%Coef(I) * exp((0.0_DP, 1.0_DP)*DPI/Tx * X * I)
    End Do


    Return
  End Function Eval_Serie_1D

! ********************************
! *
  Complex (kind=DPC) Function Eval_Serie_2D(Serie, X, Y, Tx, Ty) Result (Val)
! *
! ********************************
! * Evaluates the fourier Serie in
! * the point (X,Y) with periods 
! * Tx and Ty.
! ********************************
    
    Type (Fourier_Serie_2D), Intent (in) :: Serie
    Real (kind=DP), Intent (in) :: X, Y, Tx, Ty


    Val = (0.0_DP, 0.0_DP)
    Do J = -Serie%Nterm, Serie%Nterm
       Do I = -Serie%Nterm, Serie%Nterm
          Val = Val + Serie%Coef(I,J) * &
               & exp((0.0_DP, 1.0_DP)*DPI/Tx * X * I) * &
               & exp((0.0_DP, 1.0_DP)*DPI/Ty * Y * J)
       End Do
    End Do

    Return
  End Function Eval_Serie_2D


! ********************************
! *
  Subroutine Save_1D(Serie, File)
! *
! ********************************
! * Save the fourier modes of 
! * "Serie" in the File "File"
! ********************************

    Type (Fourier_Serie), Intent (in) :: Serie
    Character (len=*), Intent (in) :: File 

    Character (len=21) :: Frmt


    Open (Unit = 23, File = File, Action = "WRITE")

    Write(frmt,'(1A1,1I12.12,1A8)')'(',2*Serie%Nterm+1,'ES33.25)'
    
    Write(23,'(I12)')Serie%Nterm
    Write(23, frmt)(Serie%Coef(N1), N1 = -Serie%Nterm, Serie%Nterm)


    Close (23)

    Return
  End Subroutine Save_1D

! ********************************
! *
  Subroutine Save_2D(Serie, File)
! *
! ********************************
! * Save the fourier modes of 
! * "Serie" in the File "File"
! ********************************

    Type (Fourier_Serie_2D), Intent (in) :: Serie
    Character (len=*), Intent (in) :: File 

    Character (len=21) :: Frmt


    Open (Unit = 23, File = File, Action = "WRITE")

    Write(frmt,'(1A1,1I12.12,1A8)')'(',2*Serie%Nterm+1,'ES33.25)'
    
    Write(23,'(I12)')Serie%Nterm
    Do N2 = -Serie%Nterm, Serie%Nterm
       Write(23, frmt)(Serie%Coef(N1, N2), N1 = -Serie%Nterm, Serie%Nterm)
    End Do

    Close (23)

    Return
  End Subroutine Save_2D

! ********************************
! *
  Subroutine Read_1D(Serie, File)
! *
! ********************************
! * Reads the fourier modes from 
! * a the file File
! ********************************

    Character (len=*), Intent (in) :: File 
    Type (Fourier_Serie), Intent (out) :: Serie

    Character (len=21) :: Frmt

    Open (Unit = 23, File = File, Action = "READ")

    Read(23,'(I12)')Nterm

    Write(frmt,'(1A1,1I12.12,1A8)')'(',2*Serie%Nterm+1,'ES33.25)'

    Read(23, frmt)(Serie%Coef(N1), N1 = -Serie%Nterm, Serie%Nterm)

    Close (23)

    Return
  End Subroutine Read_1D

! ********************************
! *
  Subroutine Read_2D(Serie, File)
! *
! ********************************
! * Reads the fourier modes from 
! * a the file File
! ********************************

    Character (len=*), Intent (in) :: File 
    Type (Fourier_Serie_2D), Intent (out) :: Serie

    Character (len=21) :: Frmt

    Open (Unit = 23, File = File, Action = "READ")

    Read(23,'(I12)')Nterm

    Write(frmt,'(1A1,1I12.12,1A8)')'(',2*Serie%Nterm+1,'ES33.25)'

    Do N2 = -Serie%Nterm, Serie%Nterm
       Read(23, frmt)(Serie%Coef(N1, N2), N1 = -Serie%Nterm, Serie%Nterm)
    End Do

    Close (23)

    Return
  End Subroutine Read_2D

! NEW!!

! ********************************
! *
  Type (Fourier_Serie_2D) Function ProdCcte_2D(D, Serie2) Result (Prod)
! *
! ********************************
! * Calculates the product of a 
! * Fourier series and a number.
! ********************************

    Type (Fourier_Serie_2D), Intent (in) :: Serie2
    Complex (kind=DPC), Intent (in) :: D

    CALL Init_Serie(Prod, Serie2%Nterm)

    Prod%Coef = D * Serie2%Coef

    Return
  End Function ProdCcte_2D

! ********************************
! *
  Type (Fourier_Serie_2D) Function ProdCcte2_2D(Serie2, D) Result (Prod)
! *
! ********************************
! * Calculates the product of a 
! * Fourier series and a number.
! ********************************

    Type (Fourier_Serie_2D), Intent (in) :: Serie2
    Complex (kind=DPC), Intent (in) :: D

    CALL Init_Serie(Prod, Serie2%Nterm)

    Prod%Coef = D * Serie2%Coef

    Return
  End Function ProdCcte2_2D

! ********************************
! *
  Type (Fourier_Serie) Function ProdCcte(D, Serie2)
! *
! ********************************
! * Calculates the product of a
! * Fourier series and a number.
! ********************************

    Type (Fourier_Serie), Intent (in) :: Serie2
    Complex (kind=DPC), Intent (in) :: D
    
    CALL Init_Serie(ProdCcte, Serie2%Nterm)

    ProdCcte%Coef = D * Serie2%Coef

    Return
  End Function ProdCcte

! ********************************
! *
  Type (Fourier_Serie) Function ProdCcte2(Serie2, D)
! *
! ********************************
! * Calculates the product of a
! * Fourier series and a number.
! ********************************

    Type (Fourier_Serie), Intent (in) :: Serie2
    Complex (kind=DPC), Intent (in) :: D
    
    CALL Init_Serie(ProdCcte2, Serie2%Nterm)

    ProdCcte2%Coef = D * Serie2%Coef

    Return
  End Function ProdCcte2

! ********************************
! *
  Type (Fourier_Serie) Function ConjgFS_1D(Serie) Result (Cserie)
! *
! ********************************
! * Calculates the Fast Fourier
! * Transformation from the complex
! * data stored in data.
! *
! * This routine does not work!!!
! ********************************

    Type (Fourier_Serie), Intent (in) :: Serie

    CALL Init_Serie(Cserie, Serie%Nterm)
    
    Do K1 = -Serie%Nterm, Serie%Nterm
       Cserie%Coef(K1) = Conjg(Serie%Coef(-K1))
    End Do

    Return
  End Function ConjgFS_1D

! ********************************
! *
  Type (Fourier_Serie_2D) Function ConjgFS_2D(Serie) Result (Cserie)
! *
! ********************************
! * Calculates the Fast Fourier
! * Transformation from the complex
! * data stored in data.
! *
! * This routine does not work!!!
! ********************************

    Type (Fourier_Serie_2D), Intent (in) :: Serie

    CALL Init_Serie(Cserie, Serie%Nterm)
    
    Do K1 = -Serie%Nterm, Serie%Nterm
       Do K2 = -Serie%Nterm, Serie%Nterm
          Cserie%Coef(K1,K2) = Conjg(Serie%Coef(-K1,-K2))
       End Do
    End Do

    Return
  End Function ConjgFS_2D


End MODULE FourierF

