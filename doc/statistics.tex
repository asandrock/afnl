This is the documentation of the \texttt{MODULE Statistics}, a set
of \texttt{FORTRAN 90} routines to perform statistical description
of data. This module make use of the \texttt{MODULE NumTypes},
\texttt{MODULE Constants}, \texttt{MODULE Error} and \texttt{MODULE
  Linear} so please read the documentation of these modules
\emph{before} reading this. 

\section{Function \texttt{Mean(X)}}
\index{Mean@Function \texttt{Mean(X)}}

\subsection{Description}

Compute the mean value of the numbers stored in \texttt{X(:)}.

\subsection{Arguments}

\begin{description}
\item[\texttt{X(:)}:] Double (DP) or simple (SP) precision one
  dimensional array. The values  whose mean we want to compute.
\end{description}

\subsection{Output}

A real double or simple precision (same type as the input). The mean
of the values.

\subsection{Examples}

\begin{lstlisting}[emph=Mean,
                   emphstyle=\color{blue},
                   frame=trBL,
                   caption=Computing the Mean of a vector of numbers.,
                   label=mean]
Program Tests

  USE NumTypes
  USE Error
  USE Statistics

  Integer, Parameter :: Nmax = 100
  Real (kind=DP) :: X(Nmax)

  CALL Random_Number(X)
  Write(*,'(ES33.25)')Mean(X)

  Stop
End Program Tests
\end{lstlisting}

\section{Function \texttt{Median(X)}}
\index{Median@Function \texttt{Median(X)}}

\subsection{Description}

Compute the median value of the numbers stored in \texttt{X(:)}.

\subsection{Arguments}

\begin{description}
\item[\texttt{X(:)}:] Double (DP) or simple (SP) precision one
  dimensional array. The values  whose median we want to compute.
\end{description}

\subsection{Output}

A real double or simple precision (same type as the input). The median
of the values.

\subsection{Examples}

\begin{lstlisting}[emph=Median,
                   emphstyle=\color{blue},
                   frame=trBL,
                   caption=Computing the Median of a vector of numbers.,
                   label=mean]
Program Tests

  USE NumTypes
  USE Error
  USE Statistics

  Integer, Parameter :: Nmax = 5
  Real (kind=SP) :: X(Nmax) = (/1.0, 1.0, 2.0, 4.0, 1.5/)  

  Write(*,'(ES33.25)')Median(X)


  Stop
End Program Tests
\end{lstlisting}


\section{Function \texttt{Var(X)}}
\index{Var@Function \texttt{Var(X)}}

\subsection{Description}

Compute the variance of a vector of numbers \texttt{X(:)}

\subsection{Arguments}

\begin{description}
\item[\texttt{X(:)}:] Double (DP) or simple (SP) precision one
  dimensional array. The values  whose variance we want to compute.
\end{description}

\subsection{Output}

A real double or simple precision (same type as the input). The
variance of the values.

\subsection{Examples}

\begin{lstlisting}[emph=Var,
                   emphstyle=\color{blue},
                   frame=trBL,
                   caption=Computing the Variance of a set of numbers.,
                   label=var]
Program Tests

  USE NumTypes
  USE Error
  USE Statistics

  Integer, Parameter :: Nmax = 100, Npinta = 100, Npar = 4
  Real (kind=DP) :: X(Nmax), Y(Nmax), Yer(Nmax), &
       & Coef(Npar), Cerr(Npar), Corr, Xd(Nmax,2)


  CALL Random_Number(X)
  Write(*,'(ES33.25)')Var(X)


  Stop
End Program Tests
\end{lstlisting}


\section{Function \texttt{Stddev(X)}}
\index{Stddev@Function \texttt{Stddev(X)}}

\subsection{Description}

Computes the standard deviation of the numbers stored in the vector
\texttt{X(:)}. 

\subsection{Arguments}

\begin{description}
\item[\texttt{X(:)}:] Double (DP) or simple (SP) precision one
  dimensional array. The values  whose standard deviation we want to
  compute. 
\end{description}

\subsection{Output}

Real Single or Double precision, the same as the input values. The
standard deviation of the values.

\subsection{Examples}

\begin{lstlisting}[emph=Stddev,
                   emphstyle=\color{blue},
                   frame=trBL,
                   caption=Compputing the standard deviation.,
                   label=stddev]
Program Tests

  USE NumTypes
  USE Error
  USE Statistics

  Integer, Parameter :: Nmax = 100, Npinta = 100, Npar = 4
  Real (kind=DP) :: X(Nmax), Y(Nmax), Yer(Nmax), &
       & Coef(Npar), Cerr(Npar), Corr, Xd(Nmax,2)


  CALL Random_Number(X)
  Write(*,'(ES33.25)')Stddev(X)


  Stop
End Program Tests
\end{lstlisting}

\section{Function \texttt{Moment(X, k)}}
\index{Moment@Function \texttt{Moment(X, k)}}

\subsection{Description}

Returns the $k^{\underline{th}}$ moment of the values stored in the
vector \texttt{X(:)}.

\subsection{Arguments}

\begin{description}
\item[\texttt{X(:)}:] Real (Single or Double precision). The numbers
  whose $k^{\underline{th}}$ moment we want to compute.
\item[\texttt{k}:] Integer. Which moment we want to compute.
\end{description}

\subsection{Output}

Real single or double precision. The $k^{\underline{th}}$ moment of
the numbers.

\subsection{Examples}

\begin{lstlisting}[emph=Moment,
                   emphstyle=\color{blue},
                   frame=trBL,
                   caption=Computing the k$^{\text{\underline{th}}}$
                   moment of a data set.,
                   label=moment]
Program Tests

  USE NumTypes
  USE Error
  USE Statistics

  Integer, Parameter :: Nmax = 100, Npinta = 100, Npar = 4
  Real (kind=DP) :: X(Nmax), Y(Nmax), Yer(Nmax), &
       & Coef(Npar), Cerr(Npar), Corr, Xd(Nmax,2)


  CALL Random_Number(X)
  Write(*,*)'We should obtain the same numbers twice: '
  Write(*,'(ES33.25)')Moment(X,2), Var(X)

  Stop
End Program Test
\end{lstlisting}

\section{Subroutine \texttt{Normal(X, [Rm], [Rsig])}}
\index{Normal@Subroutine \texttt{Normal(X, [Rm], [Rsig])}}

\subsection{Description}

Fills \texttt{X(:)} with numbers from a normal distribution with mean
\texttt{Rm}, and standard deviation \texttt{Rsig}. The parameters
\texttt{Rm} and \texttt{Rsig} are optional. If they are not given the
mean will be 0, and the standard deviation 1.

\subsection{Arguments}

\begin{description}
\item[\texttt{X(:)}:] Real (Single or Double precision) one
  dimensional array. A vector that will be filled with numbers
  according to the normal distribution.
\item[\texttt{Rm}:] Real (Single or Double precision), Optional. The
  mean of the normal distribution. If not present the default value
  is 0.
\item[\texttt{Rsig}:] Real (Single or Double precision), Optional. The
  standard deviation of the normal distribution.  If not present the
  default value is 1. 
\end{description}

\subsection{Examples}

\begin{lstlisting}[emph=Normal,
                   emphstyle=\color{blue},
                   frame=trBL,
                   caption=Obtaining numbers with a normal distribution.,
                   label=normal]
Program Tests

  USE NumTypes
  USE Error
  USE Statistics

  Integer, Parameter :: Nmax = 100
  Real (kind=DP) :: X(Nmax)


  CALL Normal(X, 1.23_DP, 0.345_DP)
  ! Now compute the mean and standard deviation of the data
  Write(*,*)'We should obtain 1.23 and 0.345: '
  Write(*,'(ES33.25)')Mean(X), Stddev(X)


  Stop
End Program Tests
\end{lstlisting}


\section{Subroutine \texttt{FishTipp(X, Rm, Rb)}}
\index{FishTipp@Subroutine \texttt{FishTipp(X, Rm, Rb)}}

\subsection{Description}

Fills \texttt{X(:)} with numbers from a Fisher-Tippet distribution with
parameters\footnote{More info about this distribution in the
  Wikipedia: \href{http://en.wikipedia.org/wiki/Fisher-Tippett_distribution}{\texttt{http://en.wikipedia.org/wiki/Fisher-Tippett\_distribution}}} \texttt{Rm}, and $2\mathtt{Rb}^2$.

\subsection{Arguments}

\begin{description}
\item[\texttt{X(:)}:] Real (Single or Double precision) one
  dimensional array. A vector that will be filled with numbers
  according to the normal distribution.
\item[\texttt{Rm}:] Real (Single or Double precision). 
\item[\texttt{Rb}:] Real (Single or Double precision). 
\end{description}

\subsection{Examples}

\begin{lstlisting}[emph=FishTipp,
                   emphstyle=\color{blue},
                   frame=trBL,
                   caption=Obtaining numbers with a Fisher-Tippet distribution.,
                   label=fishtipp]
Program Tests

  USE NumTypes
  USE Error
  USE Statistics

  Integer, Parameter :: Nmax = 100
  Real (kind=DP) :: X(Nmax)


  CALL FishTipp(X, 2.00_DP, 1.00_DP)
  ! Now compute the mean and standard deviation of the data
  Write(*,*)'We should obtain 2.57721... and 1.2782...: '
  Write(*,'(ES33.25)')Mean(X), Stddev(X)


  Stop
End Program Tests
\end{lstlisting}


\section{Subroutine \texttt{Laplace(X, Rm, Rb)}}
\index{Laplace@Subroutine \texttt{Laplace(X, Rm, Rb)}}

\subsection{Description}

Fills \texttt{X(:)} with numbers from a Laplace distribution with mean
\texttt{Rm}, and variance $2\mathtt{Rb}^2$. 

\subsection{Arguments}

\begin{description}
\item[\texttt{X(:)}:] Real (Single or Double precision) one
  dimensional array. A vector that will be filled with numbers
  according to the Laplace distribution.
\item[\texttt{Rm}:] Real (Single or Double precision). The
  mean of the Laplace distribution.
\item[\texttt{Rb}:] Real (Single or Double precision). The
  width of the Laplace distribution (i.e. The variance is
  $2\mathtt{Rb}^2$).
\end{description}

\subsection{Examples}

\begin{lstlisting}[emph=Laplace,
                   emphstyle=\color{blue},
                   frame=trBL,
                   caption=Obtaining numbers with a Laplace distribution.,
                   label=laplace]
Program Tests

  USE NumTypes
  USE Error
  USE Statistics

  Integer, Parameter :: Nmax = 100
  Real (kind=DP) :: X(Nmax)


  CALL Laplace(X, 1.23_DP, 1.0_DP)
  ! Now compute the mean and standard deviation of the data
  Write(*,*)'We should obtain 1.23 and sqrt(2): '
  Write(*,'(ES33.25)')Mean(X), Stddev(X)


  Stop
End Program Tests
\end{lstlisting}

\section{Subroutine \texttt{Histogram(Val, Ndiv, Ntics, Vmin, Vmax,
    h)}} 
\index{Histogram@Subroutine \texttt{Histogram(Val, Ndiv, Ntics, Vmin, Vmax, h)}} 

\subsection{Description}

Given a set of points \texttt{Val(:)}, this routine makes
\texttt{Ndiv} divisions between the minimum and the greatest value of
\texttt{Val} (respectively returned in \texttt{Vmin} and
\texttt{Vmax}), each of size \texttt{h} (also returned), and returns
in the integer vector \texttt{Nticks(:)} the number of points that are
in each interval. 

\subsection{Arguments}

\begin{description}
\item[\texttt{Val(:)}:] Real (Single or Double precision) one
  dimensional array. The original values.
\item[\texttt{Ndiv}: ] Integer. The number of divisions.
\item[\texttt{Nticks}:] Integer one dimensional array. \texttt{Ndiv(I)}
  Tells how many points of \texttt{Val(:)} are between
  $\mathtt{Vmin+(I-1)h}$ and $\mathtt{Vmin+Ih}$.
\item[\texttt{Vmin, Vmax}:] Real (Single or Double precision). The
  minimum and maximum values of \texttt{Val}.
\item[\texttt{h}:] Real (Single or Double precision). After calling
  the routine has the step of the division.
\end{description}

\subsection{Examples}

\begin{lstlisting}[emph=Histogram,
                   emphstyle=\color{blue},
                   frame=trBL,
                   caption=Making Histograms.,
                   label=histogram]
Program Tests

  USE NumTypes
  USE Error
  USE Statistics

  Integer, Parameter :: Nmax = 500000, Npinta = 100, Npar = 4, Ndiv = 100
  Real (kind=DP) :: X(Nmax), Y(Nmax), Yer(Nmax), &
       & Coef(Npar), Cerr(Npar), Corr, Xd(Nmax,2), &
       & Xmin, Xmax, h, Xac
  Integer :: Ntics(Ndiv)

  CALL Normal(X, 1.23_DP, 0.345_DP)
  CALL Histogram(X, Ndiv, Ntics, Xmin, Xmax, h)
  
  Do I = 1, Ndiv
     Xac = Xmin + (I-1)*h
     Write(*,'(1ES33.25,1I)')Xac, Ntics(I)
  End Do

  Stop
End Program Tests
\end{lstlisting}

\section{Subroutine \texttt{LinearReg(X, Y, Yerr, [Func], Coef, Cerr, ChisqrV)}} 
\index{LinearReg@Subroutine \texttt{LinearReg(X, Y, Yerr, [Func], Coef, Cerr, ChisqrV)}} 

\subsection{Description}

Given a set of points \texttt{X(:)} and \texttt{Y(:)}, this routine
performs a linear fit to a set of functions defined by
\texttt{Func}. 
\begin{displaymath}
  Y = \sum_i a_i f_i(X)
\end{displaymath}
This routine also performs multi-dimensional fitting, in which case
the points are specified as \texttt{X(:,:)}, where the first argument
tells which point, and the second which variable.

\subsection{Arguments}

\begin{description}
\item[\texttt{X(:[,:])}:] Real single or double precision one
  dimensional array (for a one dimensional fit) or two dimensional
  array (for a multidimensional fit). The
  independent variables. For a multidimensional fit, the first argument
  tells which point, and the second which variable. So the size of the
  array should be \texttt{X(Npoints,Ndim)}.
\item[\texttt{Y(:)}: ] Real single or double precision one dimensional
  array. The dependent
  variable.
\item[\texttt{Yerr(:)}:] Real single or double precision one
  dimensional array. The errors
  of the points. If you don't have them, you should put all of hem to
  some non-zero value.
\item[\texttt{Func}:] Optional. This routine define the functions to
  fit. An interface like this should be provided
\begin{verbatim}
Interface
   Function Func(Xx, i)
         
     USE NumTypes

     Real (kind=SP), Intent (in) :: Xx
     Integer, Intent (in) :: i
     Real (kind=SP) :: Func

   End Function Func
End Interface
\end{verbatim}
if you want to perform a one dimensional fitting, and like this
\begin{verbatim}
Interface
   Function Func(Xx, i)
         
     USE NumTypes

     Real (kind=SP), Intent (in) :: Xx(:)
     Integer, Intent (in) :: i
     Real (kind=SP) :: Func

   End Function Func
End Interface
\end{verbatim}
if it is a multidimensional fitting. Since you are making a fitting
to a function of the type
\begin{displaymath}
  Y = \sum_i a_i f_i(X)
\end{displaymath}
the values $f_i(X)$ are given by this function as \texttt{Func(X,
  I)}. If the functions are not specified (i.e. you don't put this
argument), a fit to a polynomial is made (this only work for
one-dimensional fittings).
\item[\texttt{Coef(:)}: ] Real single or double precision one
  dimensional array. The
  parameters that you want to determine.
\item[\texttt{Cerr(:)}:] Real single or double precision one
  dimensional array. The errors
  in the parameters.
\item[\texttt{ChiSqr}: ] Real single or double precision. The $\chi^2$
  per degree of freedom of the fit.
\end{description}

\subsection{Examples}

\begin{lstlisting}[emph=LinearReg,
                   emphstyle=\color{blue},
                   frame=trBL,
                   caption=Doing linear regressions.,
                   label=linearreg]
Program Tests

  USE NumTypes
  USE Error
  USE Statistics

  Integer, Parameter :: Nmax = 200, Npinta = 100, Npar = 4, Ndiv = 100
  Real (kind=DP) :: X(Nmax), Y(Nmax), Yer(Nmax), &
       & Coef(Npar), Cerr(Npar), Corr, Xd(Nmax,2), &
       & Xmin, Xmax, h, Xac
  Integer :: Ntics(Ndiv)

  Interface
     Function Fd(Xx, i)
       
       USE NumTypes
       
       Real (kind=DP), Intent (in) :: Xx(:)
       Integer, Intent (in) :: i
       Real (kind=DP) :: Fd
       
     End Function FD
  End Interface


  CALL Random_Number(Xd)
  Xd(:,:) = 10.0_DP*(Xd(:,:) - 0.8_DP)

  CALL Normal(Yer, 0.0_DP, 1.0E-3_DP)
  Y(:) = 12.34_DP*Xd(:,1)*sin(Xd(:,2)) - 2.23_DP + &
       & 0.67_DP*Xd(:,1)**2*Xd(:,2) +  0.23_DP*Xd(:,1) + Yer(:) 


  CALL LinearReg(Xd, Y, Yer, Fd, Coef, Cerr, Corr)
  
  ! This should print the adjusted parameters, 
  ! that have values: 12.34, -2.23, 0.67, 0.23
  Do I = 1, Npar
     Write(*,'(2ES33.25)')Coef(I), Cerr(I)
  End Do

  ! This prints the ChiSqr, that should be very 
  ! close to 1.
  Write(*,'(1A,1ES33.25)')'ChiSqr of the Fit: ', Corr


  Stop
End Program Tests

! ************************************
! *
Function Fd(X, i)
! *
! ************************************

  USE NumTypes

  Real (kind=DP), Intent (in) :: X(:)
  Integer, Intent (in) :: i
  Real (kind=DP) :: Fd

  If (I==1) Then
     Fd = 1.0_DP
  Else If (I==2) Then
     Fd = X(1)*sin(X(2))
  Else If (I==3) Then
     Fd = X(1)**2*X(2)
  Else If (I==4) Then
     Fd = X(1)
  End If

  Return
End Function FD
\end{lstlisting}


\section{Subroutine \texttt{NonLinearReg(X, Y, Yerr, Func, Coef, Cerr, ChisqrV)}} 
\index{NonLinearReg@Subroutine \texttt{NonLinearReg(X, Y, Yerr, Func, Coef, Cerr, ChisqrV)}} 

\subsection{Description}

Given a set of points \texttt{X(:)} and \texttt{Y(:)}, this routine
performs a non-linear fit to a set of functions defined by
\texttt{Func}.  

This routine also performs multi-dimensional fitting, in which case
the points are specified as \texttt{X(:,:)}, where the first argument
tells which point, and the second which variable.

This routine uses the Levenberg-Marquardt algorithm to perform the
optimisation\footnote{\href{http://en.wikipedia.org/wiki/Levenberg-Marquardt_algorithm}{\texttt{http://en.wikipedia.org/wiki/Levenberg-Marquardt\_algorithm}}}. 

\subsection{Arguments}

\begin{description}
\item[\texttt{X(:[,:])}:] Real single or double precision one
  dimensional array (for a one dimensional fit) or two dimensional
  array (for a multidimensional fit). The
  independent variables. For a multidimensional fit, the first argument
  tells which point, and the second which variable. So the size of the
  array should be \texttt{X(Npoints,Ndim)}.
\item[\texttt{Y(:)}: ] Real single or double precision one dimensional
  array. The dependent
  variable.
\item[\texttt{Yerr(:)}:] Real single or double precision one
  dimensional array. The errors
  of the points. If you don't have them, you should put all of them to
  some non-zero value.
\item[\texttt{Func}:] This routine define the functions to
  fit. An interface like this should be provided
\begin{verbatim}
Interface
   Subroutine Func(X, Cf, Valf, ValD)
         
     USE NumTypes

     Real (kind=SP), Intent (in) :: X, Cf(:)
     Real (kind=SP), Intent (out) :: Valf, ValD(Size(Cf))
         
   End Subroutine Func
End Interface
\end{verbatim}
if you want to perform a one dimensional fitting, and like this
\begin{verbatim}
Interface
   Subroutine Func(X, Cf, Valf, ValD)
        
     USE NumTypes

     Real (kind=SP), Intent (in) :: X(:), Cf(:)
     Real (kind=SP), Intent (out) :: Valf, ValD(Size(Cf))
         
   End Subroutine Func
End Interface
\end{verbatim}
if it is a multidimensional fitting. 

This routine returns the values of the function at $X$ for some values
of the parameters given in $\mathtt{Cf}$ in the variable
$\mathtt{Valf}$, and a vector with the derivatives (respect with the
parameters) in $\mathtt{ValD(:)}$. 
\item[\texttt{Coef(:)}: ] Real single or double precision one
  dimensional array. Output. The
  parameters that you want to determine.
\item[\texttt{Cerr(:)}:] Real single or double precision one
  dimensional array. Outpue. The errors
  in the parameters.
\item[\texttt{ChiSqr}: ] Real single or double precision. The $\chi^2$
  per degree of freedom of the fit.
\end{description}

\subsection{Examples}

In this example we will fit some generated data, with a Normal noise
to the function
\begin{displaymath}
  f(x_1,x_2;a,b) = \sin(ax_1) + bx_1x_2
\end{displaymath}
We will generate the data with the values $a=2.0$ and $b=0.2$, so our
fitting routine \emph{should} return this values within errors.

The derivatives of the function (repect the parameters $a$ and $b$),
as well as the value of function are given by the user routine
\texttt{Func}. The derivatives are:
\begin{eqnarray*}
  \frac{\partial f(x_1,x_2;a,b)}{\partial a} &=& x_1\cos{ax_1} \\
  \frac{\partial f(x_1,x_2;a,b)}{\partial b} &=& x_1x_2 \\
\end{eqnarray*}


\begin{lstlisting}[emph=NonLinearReg,
                   emphstyle=\color{blue},
                   frame=trBL,
                   caption=Doing non linear regressions.,
                   label=linearreg]
Program NLFit

  USE NumTypes
  USE Statistics

  Interface
     Subroutine Func(X, Cf, Valf, ValD)
       
       USE NumTypes
       
       Real (kind=DP), Intent (in) :: X(:), Cf(:)
       Real (kind=DP), Intent (out) :: Valf, ValD(Size(Cf))
       
     End Subroutine Func
  End Interface

  Integer, Parameter :: Np = 20, Ndim = 2
  Real (kind=DP) :: X(Np, Ndim), Y(Np), Ye(Np), Co(2), Vd(2), Ce(2), Ch

  ! First Fill the data
  CALL Random_Number(X)
  X = 2.0_DP*(X - 0.5_DP)
  Co(1) = 2.0_DP
  Co(2) = 0.2_DP
  CALL Normal(Ye, 0.0_DP, 0.5_DP)
  Do I = 1, Np
     CALL Func(X(I,:), Co, Y(I), Vd)
     Y(I) = Y(I) + Ye(I)
  End Do
  

  ! Now Perform the non linear fit
  Co = 1.0_DP
  CALL NonLinearReg(X, Y, Abs(Ye), Func, Co, Ce, Ch)
  Do I = 1, Npar
    Write(*,'(1A,100ES33.25)')'Parameter and error: ', Co(I), Ce(I)
  End Do
  Write(*,'(1A,100ES33.25)')&
  & 'Chi Square per degree of freedom of the Fit: ', Ch


  Stop
End Program NLFit

Subroutine Func(X, Cf, Valf, ValD)
  
  USE NumTypes
  
  Real (kind=DP), Intent (in) :: X(:), Cf(:)
  Real (kind=DP), Intent (out) :: Valf, ValD(Size(Cf))

  Valf = Sin(Cf(1)*X(1)) + Cf(2)*X(1)*X(2)
  ValD(1) = X(1)*Cos(Cf(1)*X(1))
  ValD(2) = X(1)*X(2)

  
End Subroutine Func
\end{lstlisting}

\section{Subroutine/Function \texttt{Irand([Irnd], N, M)}}
\index{Irand@Subroutine/Function \texttt{Irand([Irnd], N, M)}}

\subsection{Description}

If present, fills \texttt{Irnd(:)} with random integer numbers between
\texttt{N} and \texttt{M} with an uniform distribution. If
\texttt{Irnd(:)} is not present returns a integer random number
between \texttt{N} and \texttt{M}.

\subsection{Arguments}

\begin{description}
\item[\texttt{Irnd(:)}:] Integer, Optional. A vector that will be
  filled with integer numbers according to a uniform distribution.
\item[\texttt{N}:] Integer. The minimum number that we can obtain.
\item[\texttt{M}:] Integer. The maximum number that we can obtain.
\end{description}

\subsection{Examples}

\begin{lstlisting}[emph=Irand,
                   emphstyle=\color{blue},
                   frame=trBL,
                   caption=Obtaining integer random numbers.,
                   label=irand]
Program Tests

  USE NumTypes
  USE Error
  USE Statistics

  Integer, Parameter :: Nmax = 100
  Integer :: Irnd(Nmax)


  CALL Irand(Irnd, 0, 1)
  ! Now compute the mean 
  Write(*,*)'We should obtain 0.5: '
  Write(*,'(ES33.25)')Mean(Real(Irnd(:),kind=DP))


  Stop
End Program Tests
\end{lstlisting}

\section{Subroutine \texttt{Permutation(Idx)}}
\index{Permutation@Subroutine \texttt{Permutation(Idx)}}

\subsection{Description}

Returns a random permutation of $\mathtt{N}$ elements. It uses the
Knuth shuffle algorithm\footnote{\href{http://en.wikipedia.org/wiki/Knuth_shuffle}{\texttt{http://en.wikipedia.org/wiki/Knuth\_shuffle}}}.

\subsection{Arguments}

\begin{description}
\item[\texttt{Idx(:): }] Integer  one dimensional array. Output. The
  random permutation.
\end{description}

\begin{lstlisting}[emph=Permutation,
                   emphstyle=\color{blue},
                   frame=trBL,
                   caption=Obtaining a permutation.,
                   label=Permutation]
Program Tests

  USE NumTypes
  USE Error
  USE Statistics

  Integer, Parameter :: Nmax = 10
  Integer :: Id(Nmax)


  CALL Permutation(Id)
  Write(*,'(100I3)')(Id(I), I = 1, Nmax)

  Stop

End Program Tests
\end{lstlisting}


\section{Subroutine \texttt{BootStrap(Ibt)}}
\index{Bootstrap@Subroutine \texttt{BootStrap(Ibt)}}

\subsection{Description}

Generates $\mathtt{N_b}$ bootstrap sequence of $\mathtt{N}$ numbers
each. These bootstraps are returned in the two dimensional integer
array $\mathtt{Ibt(:,:)}$ of size $\mathtt{N\times N_b}$.

\subsection{Arguments}

\begin{description}
\item[\texttt{Ibt(:)}:] Integer. A two dimensional array of size
  $\mathtt{N\times N_b}$, where $\mathtt{N_b}$ is the number of
  bootstraps, and $\mathtt{N}$ is the range of each bootstrap.
\end{description}

\subsection{Examples}

\begin{lstlisting}[emph=Bootstrap,
                   emphstyle=\color{blue},
                   frame=trBL,
                   caption=Resampling some data.,
                   label=bootstrap]
Program Tests

  USE NumTypes
  USE Error
  USE Statistics

  Integer, Parameter :: Nmax = 8, Nbt = 5
  Real (kind=DP) :: X(Nmax)
  Integer :: Ib(Nmax, Nbt), I, J


  CALL Random_Number(X)
  ! Generate 5 bootstraps
  CALL BootStrap(Ib)

  ! Write the original sample, and the bootstraps
  Write(*,'(1000ES33.25)')(X(J), J=1, Nmax) 
  Do I = 1, Nbt
     Write(*,'(1000ES33.25)')(X(Ib(J)), J=1, Nmax) 
  End Do

  Stop
End Program Tests
\end{lstlisting}

\section{Subroutine \texttt{SaveBstrp(Ibt, Filename)}}
\index{SaveBstrp@Subroutine \texttt{SaveBstrp(Ibt, Filename)}}

\subsection{Description}

Saves the bootstrap stored in $\mathtt{Ibt}$ and saves it in the file
\texttt{Filename}.

\subsection{Arguments}

\begin{description}
\item[\texttt{Ibt(:)}:] Integer. A two dimensional array of size
  $\mathtt{N\times N_b}$, where $\mathtt{N_b}$ is the number of
  bootstraps, and $\mathtt{N}$ is the range of each bootstrap.
\item[\texttt{Filename}: ] Character (len=*). A file name to save the
  resampling data.
\end{description}

\subsection{Examples}

\begin{lstlisting}[emph=SaveBstrp,
                   emphstyle=\color{blue},
                   frame=trBL,
                   caption=Reading the resampling info.,
                   label=SaveBstrp]
Program Tests

  USE NumTypes
  USE Error
  USE Statistics

  Integer, Parameter :: Nmax = 8, Nbt = 5
  Integer :: Ib(Nmax, Nbt)


  ! Generate 5 bootstraps
  CALL BootStrap(Ib)

  ! Save it
  SaveBstrp(Ibt, 'example.bst')

  Stop
End Program Tests
\end{lstlisting}

\section{Subroutine \texttt{ReadBstrp(Ibt, Filename)}}
\index{ReadBstrp@Subroutine \texttt{ReadBstrp(Ibt, Filename)}}

\subsection{Description}

Reads the bootstrap stored in the file \texttt{Filename}, and returns
it in  $\mathtt{Ibt}$.

\subsection{Arguments}

\begin{description}
\item[\texttt{Ibt(:)}:] Integer. A two dimensional array of size
  $\mathtt{N\times N_b}$, where $\mathtt{N_b}$ is the number of
  bootstraps, and $\mathtt{N}$ is the range of each bootstrap.
\item[\texttt{Filename}: ] Character (len=*). A file name to read the
  resampling data.
\end{description}

\subsection{Examples}

\begin{lstlisting}[emph=ReadBstrp,
                   emphstyle=\color{blue},
                   frame=trBL,
                   caption=Saving the resampling info.,
                   label=ReadBstrp]
Program Tests

  USE NumTypes
  USE Error
  USE Statistics

  Integer, Parameter :: Nmax = 8, Nbt = 5
  Integer :: Ib(Nmax, Nbt)


  ! Read a saved Bootstrap.
  ReadBstrp(Ibt, 'example.bst')

  Stop
End Program Tests
\end{lstlisting}

\section{Subroutine \texttt{EstBstrp(Data, Ibt, Func, Val, Err[, Rest])}}
\index{EstBstrp@Subroutine \texttt{EstBstrp(Data, Ibt, Func, Val, Err)}}

\subsection{Description}

Estimates using the Bootstrap method the average and error of an
estimator given as a user supplied function.

\subsection{Arguments}

\begin{description}
\item[\texttt{Data(:)}:] Double precision Real. A one dimensional
  array with the original sampling.
\item[\texttt{ibt(:,:): }] Integer two dimensional array. The bootstrap
  that we want to use to make the estimation.
\item[\texttt{Func}: ] A user suplied function that returns the value
  of the estimator. An interface block of the following type should be
  defined. 
\begin{verbatim}
    Interface 
       Function Func(X)
         USE NumTypes
         
         Real (kind=DP), Intent (in) :: X(:)
         Real (kind=DP) :: Func

       End Function Func
    End Interface
\end{verbatim}
\item[\texttt{Val}: ] Double precision real. Output. The value of the 
  estimation of the parameter. 
\item[\texttt{Err}: ] Double precision real. Output. An estimation of
  the error in the estimation of the parameter. 
\item[\texttt{Rest}: ] Double precision real one dimensional array
  (same dimension as the number of bootstraps in
  \texttt{Ibt}). Output. The value of the estimator for each
  resampling. 
\end{description}

\subsection{Examples}

\begin{lstlisting}[emph=EstBstrp,
                   emphstyle=\color{blue},
                   frame=trBL,
                   caption=Estimating the average.,
                   label=EstBstrp]
Program Tests

  USE NumTypes
  USE Error
  USE Statistics

  Integer, Parameter :: Nmax = 100, Nbt = 50
  Integer :: Ib(Nmax, Nbt)
  Real (kind=DP) :: Avg, Err, Data(Nmax), Rest(Nbt)

  Interface 
     Function F(X)
       USE NumTypes
         
       Real (kind=DP), Intent (in) :: X(:)
       Real (kind=DP) :: F

     End Function F
  End Interface

  ! Read a saved Bootstrap, and the data from a file
  ReadBstrp(Ibt, 'example.bst')
  Open (Unit=22, File="data.dat")
  Read(22,*)Data
  Close(22)

  ! And estimate the average
  CALL EstBstrp(Data, Ibt, F, Avg, Err, Rest)

  ! Print the Average of each resampling
  Do I = 1, Nbt
    Write(*,*)I, Rest(I)
  End Do

  Stop
End Program Tests

Function F(X)
  USE NumTypes
  USE Statistics
         

  Real (kind=DP), Intent (in) :: X(:)
  Real (kind=DP) :: F

  F = Mean(X)

End Function F

\end{lstlisting}


\section{Subroutine \texttt{BstrpConfInt(Data, Ibt, alpha, Func, dmin, dpls))}}
\index{BstrpConfInt@Subroutine \texttt{BstrpConfInt(Data, Ibt, alpha, Func, dmin, dpls)}}

\subsection{Description}

Gives an Confidence interval for the estimator given as the user
supplied function \texttt{Func}, such that
\begin{displaymath}
  \mathcal P(dmin<Func(Data)<dpls) = 1-2\alpha
\end{displaymath}

\subsection{Arguments}

\begin{description}
\item[\texttt{Data(:)}:] Double precision Real. A one dimensional
  array with the original sampling.
\item[\texttt{ibt(:,:): }] Integer two dimensional array. The bootstrap
  that we want to use to make the estimation.
\item[\texttt{alpha}: ] Double precision real. The level of the
  confidence interval. 
\item[\texttt{Func}: ] A user suplied function that returns the value
  of the estimator. An interface block of the following type should be
  defined. 
\begin{verbatim}
    Interface 
       Function Func(X)
         USE NumTypes
         
         Real (kind=DP), Intent (in) :: X(:)
         Real (kind=DP) :: Func

       End Function Func
    End Interface
\end{verbatim}
\item[\texttt{dmin}: ] Double precision real. Output. The lower limit
  of the confidence interval.
\item[\texttt{dpls}: ] Double precision real. Output. The higher limit
  of the confidence interval.
\end{description}

\subsection{Examples}

\begin{lstlisting}[emph=BstrpConfInt,
                   emphstyle=\color{blue},
                   frame=trBL,
                   caption=Giving a confidence interval.,
                   label=BstrpConfInt]
Program Tests

  USE NumTypes
  USE Error
  USE Statistics

  Integer, Parameter :: Nmax = 1000, Nb = 10000, Ndiv = 50
  Real (kind=DP) :: Rdata(Nmax), Rmean(Nb), avg, Xmin, Xmax, h, Xac,&
       & err, dmin, dpls
  Integer :: Id(Nmax), Ib(Nb, Nmax), Ntics(Ndiv)

  Interface 
     Function F(X)
       USE NumTypes
         
       Real (kind=DP), Intent (in) :: X(:)
       Real (kind=DP) :: F
       
     End Function F
  End Interface
  
  CALL Normal(Rdata)

  avg = Mean(Rdata)
  ! Now create the resamples
  CALL Bootstrap(Ib)

  CALL EstBstrp(Rdata, Ib, F, avg, Err, Rmean)
  Write(*,*)'#', avg, Err, Mean(Rdata)

  CALL BstrpConfInt(Rdata, Ib, 0.1_DP, F, dmin, dpls)
  Write(*,*)'Intervalo:', dmin, dpls
  Write(*,*)Avg - Dmin, Dpls - Avg
  Write(*,*)(dpls - dmin)/2.0_DP, 1.64485_DP/Sqrt(Real(Nmax,kind=DP))

  Stop

End Program Tests

Function F(X)
  USE NumTypes
  USE Statistics
  
  Real (kind=DP), Intent (in) :: X(:)
  Real (kind=DP) :: F

  F = Mean(X)
  
  Return
End Function F
\end{lstlisting}



% Local Variables: 
% mode: latex
% TeX-master: "lib"
% End: 

